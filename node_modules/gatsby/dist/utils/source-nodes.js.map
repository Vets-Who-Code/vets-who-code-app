{"version":3,"sources":["../../src/utils/source-nodes.js"],"names":["_","require","report","apiRunner","store","getNode","boundActionCreators","deleteNodes","discoverPluginsWithoutNodes","storeState","nodeCreationPlugins","without","union","apiToPlugins","sourceNodes","nodeOwners","uniq","values","nodes","reduce","acc","node","push","internal","owner","difference","module","exports","traceId","waitForCascadingActions","state","getState","pluginsWithNoNodes","map","warn","name","touchedNodes","Object","keys","nodesTouched","staleNodes","filter","rootNode","whileCount","parent","undefined","console","log","includes","id","length","n"],"mappings":";;;;;;;;;;;;AAAA,IAAMA,IAAIC,QAAS,QAAT,CAAV;AACA,IAAMC,SAASD,QAAS,yBAAT,CAAf;;AAEA,IAAME,YAAYF,QAAS,mBAAT,CAAlB;;eAC2BA,QAAS,UAAT,C;IAAnBG,K,YAAAA,K;IAAOC,O,YAAAA,O;;gBACiBJ,QAAS,kBAAT,C;IAAxBK,mB,aAAAA,mB;;IACAC,W,GAAgBD,mB,CAAhBC,W;;AAER;;;;;AAIA,SAASC,2BAAT,CAAqCC,UAArC,EAAiD;AAC/C;AACA,MAAMC,sBAAsBV,EAAEW,OAAF,CAC1BX,EAAEY,KAAF,CAAQH,WAAWI,YAAX,CAAwBC,WAAhC,CAD0B,EAEzB,qBAFyB,CAA5B;AAIA;AACA,MAAMC,aAAaf,EAAEgB,IAAF,CACjBhB,EAAEiB,MAAF,CAASR,WAAWS,KAApB,EAA2BC,MAA3B,CAAkC,UAACC,GAAD,EAAMC,IAAN,EAAe;AAC/CD,QAAIE,IAAJ,CAASD,KAAKE,QAAL,CAAcC,KAAvB;AACA,WAAOJ,GAAP;AACD,GAHD,EAGG,EAHH,CADiB,CAAnB;AAMA,SAAOpB,EAAEyB,UAAF,CAAaf,mBAAb,EAAkCK,UAAlC,CAAP;AACD;;AAEDW,OAAOC,OAAP,4EAAiB;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,iBACTxB,UAAW,aAAX,EAAyB;AAC7ByB,qBAAU,qBADmB;AAE7BC,qCAAyB;AAFI,WAAzB,CADS;;AAAA;AAMTC,eANS,GAMD1B,MAAM2B,QAAN,EANC;;AAQf;;AACMC,4BATS,GASYxB,4BAA4BsB,KAA5B,CATZ;;AAUfE,6BAAmBC,GAAnB,CAAuB;AAAA,mBACrB/B,OAAOgC,IAAP,CACG,OAAMC,IAAK,wDADd,CADqB;AAAA,WAAvB;;AAMA;AACMC,sBAjBS,GAiBMC,OAAOC,IAAP,CAAYR,MAAMS,YAAlB,CAjBN;AAkBTC,oBAlBS,GAkBIxC,EAAEiB,MAAF,CAASa,MAAMZ,KAAf,EAAsBuB,MAAtB,CAA6B,gBAAQ;AACtD;AACA,gBAAIC,WAAWrB,IAAf;AACA,gBAAIsB,aAAa,CAAjB;AACA,mBACED,SAASE,MAAT,IACAvC,QAAQqC,SAASE,MAAjB,MAA6BC,SAD7B,IAEAF,aAAa,GAHf,EAIE;AACAD,yBAAWrC,QAAQqC,SAASE,MAAjB,CAAX;AACAD,4BAAc,CAAd;AACA,kBAAIA,aAAa,GAAjB,EAAsB;AACpBG,wBAAQC,GAAR,CACG,+DADH,EAEEL,QAFF;AAID;AACF;;AAED,mBAAO,CAAC1C,EAAEgD,QAAF,CAAWZ,YAAX,EAAyBM,SAASO,EAAlC,CAAR;AACD,WApBkB,CAlBJ;;;AAwCf,cAAIT,WAAWU,MAAX,GAAoB,CAAxB,EAA2B;AACzB3C,wBAAYiC,WAAWP,GAAX,CAAe;AAAA,qBAAKkB,EAAEF,EAAP;AAAA,aAAf,CAAZ;AACD;;AA1Cc;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,CAAjB","file":"source-nodes.js","sourcesContent":["const _ = require(`lodash`)\nconst report = require(`gatsby-cli/lib/reporter`)\n\nconst apiRunner = require(`./api-runner-node`)\nconst { store, getNode } = require(`../redux`)\nconst { boundActionCreators } = require(`../redux/actions`)\nconst { deleteNodes } = boundActionCreators\n\n/**\n * Finds the name of all plugins which implement Gatsby APIs that\n * may create nodes, but which have not actually created any nodes.\n */\nfunction discoverPluginsWithoutNodes(storeState) {\n  // Discover which plugins implement APIs which may create nodes\n  const nodeCreationPlugins = _.without(\n    _.union(storeState.apiToPlugins.sourceNodes),\n    `default-site-plugin`\n  )\n  // Find out which plugins own already created nodes\n  const nodeOwners = _.uniq(\n    _.values(storeState.nodes).reduce((acc, node) => {\n      acc.push(node.internal.owner)\n      return acc\n    }, [])\n  )\n  return _.difference(nodeCreationPlugins, nodeOwners)\n}\n\nmodule.exports = async () => {\n  await apiRunner(`sourceNodes`, {\n    traceId: `initial-sourceNodes`,\n    waitForCascadingActions: true,\n  })\n\n  const state = store.getState()\n\n  // Warn about plugins that should have created nodes but didn't.\n  const pluginsWithNoNodes = discoverPluginsWithoutNodes(state)\n  pluginsWithNoNodes.map(name =>\n    report.warn(\n      `The ${name} plugin has generated no Gatsby nodes. Do you need it?`\n    )\n  )\n\n  // Garbage collect stale data nodes\n  const touchedNodes = Object.keys(state.nodesTouched)\n  const staleNodes = _.values(state.nodes).filter(node => {\n    // Find the root node.\n    let rootNode = node\n    let whileCount = 0\n    while (\n      rootNode.parent &&\n      getNode(rootNode.parent) !== undefined &&\n      whileCount < 101\n    ) {\n      rootNode = getNode(rootNode.parent)\n      whileCount += 1\n      if (whileCount > 100) {\n        console.log(\n          `It looks like you have a node that's set its parent as itself`,\n          rootNode\n        )\n      }\n    }\n\n    return !_.includes(touchedNodes, rootNode.id)\n  })\n\n  if (staleNodes.length > 0) {\n    deleteNodes(staleNodes.map(n => n.id))\n  }\n}\n"]}