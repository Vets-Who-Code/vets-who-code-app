{"version":3,"sources":["../../src/schema/build-connection-fields.js"],"names":["_","require","GraphQLInt","GraphQLList","GraphQLString","GraphQLEnumType","connectionArgs","connectionDefinitions","connectionFromArray","buildFieldEnumValues","module","exports","enumValues","type","nodes","name","camelCase","nodeType","nodeObjectType","connectionFields","field","fieldValue","totalCount","groupConnection","connectionType","distinct","args","values","resolve","connection","fieldName","includes","replace","fields","edges","map","get","edge","node","sortBy","filter","uniq","flatten","identity","group","connectionNodes","groups","isArray","find","reduce","vals","n","has","concat","forEach","val","groupBy","groupConnections","sortedFieldValues","keys","each","groupNodes","groupConn","length","push"],"mappings":"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","file":"build-connection-fields.js","sourcesContent":["// @flow\nconst _ = require(`lodash`)\nconst {\n  GraphQLInt,\n  GraphQLList,\n  GraphQLString,\n  GraphQLEnumType,\n} = require(`graphql`)\nconst {\n  connectionArgs,\n  connectionDefinitions,\n  connectionFromArray,\n} = require(`graphql-skip-limit`)\n\nconst { buildFieldEnumValues } = require(`./data-tree-utils`)\n\nmodule.exports = type => {\n  const enumValues = buildFieldEnumValues(type.nodes)\n  const { connectionType: groupConnection } = connectionDefinitions({\n    name: _.camelCase(`${type.name} groupConnection`),\n    nodeType: type.nodeObjectType,\n    connectionFields: () => {\n      return {\n        field: { type: GraphQLString },\n        fieldValue: { type: GraphQLString },\n        totalCount: { type: GraphQLInt },\n      }\n    },\n  })\n\n  return {\n    totalCount: {\n      type: GraphQLInt,\n    },\n    distinct: {\n      type: new GraphQLList(GraphQLString),\n      args: {\n        field: {\n          type: new GraphQLEnumType({\n            name: _.camelCase(`${type.name} distinct enum`),\n            values: enumValues,\n          }),\n        },\n      },\n      resolve(connection, args) {\n        let fieldName = args.field\n        if (_.includes(args.field, `___`)) {\n          fieldName = args.field.replace(`___`, `.`)\n        }\n        const fields = connection.edges.map(edge => _.get(edge.node, fieldName))\n        return _.sortBy(_.filter(_.uniq(_.flatten(fields)), _.identity))\n      },\n    },\n    group: {\n      type: new GraphQLList(groupConnection),\n      args: {\n        ...connectionArgs,\n        field: {\n          type: new GraphQLEnumType({\n            name: _.camelCase(`${type.name} group enum`),\n            values: enumValues,\n          }),\n        },\n      },\n      resolve(connection, args) {\n        const fieldName = args.field.replace(`___`, `.`)\n        const connectionNodes = connection.edges.map(edge => edge.node)\n\n        let groups = {}\n        // Do a custom grouping for arrays (w/ a group per array value)\n        // Find the first node with this field and check if it's an array.\n        if (_.isArray(_.get(_.find(connectionNodes, fieldName), fieldName))) {\n          const values = _.uniq(\n            _.reduce(\n              connectionNodes,\n              (vals, n) => {\n                if (_.has(n, fieldName)) {\n                  return vals.concat(_.get(n, fieldName))\n                } else {\n                  return vals\n                }\n              },\n              []\n            )\n          )\n          values.forEach(val => {\n            groups[val] = _.filter(connectionNodes, n =>\n              _.includes(_.get(n, fieldName), val)\n            )\n          })\n        } else {\n          groups = _.groupBy(connectionNodes, fieldName)\n        }\n        const groupConnections = []\n\n        // Do default sort by fieldValue\n        const sortedFieldValues = _.sortBy(_.keys(groups))\n        _.each(sortedFieldValues, fieldValue => {\n          const groupNodes = groups[fieldValue]\n          const groupConn = connectionFromArray(groupNodes, args)\n          groupConn.totalCount = groupNodes.length\n          groupConn.field = fieldName\n          groupConn.fieldValue = fieldValue\n          groupConnections.push(groupConn)\n        })\n\n        return groupConnections\n      },\n    },\n  }\n}\n"]}