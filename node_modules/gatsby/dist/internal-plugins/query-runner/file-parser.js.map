{"version":3,"sources":["../../../src/internal-plugins/query-runner/file-parser.js"],"names":["filePath","fileStr","ast","apiRunnerNode","filename","contents","transpiled","length","item","tmp","babylon","parse","sourceType","plugins","report","error","undefined","sourceFilename","parseToAst","file","text","Promise","resolve","reject","then","queries","ExportNamedDeclaration","path","state","traverse","TaggedTemplateExpression","innerPath","gqlAst","getGraphQLTag","definitions","forEach","def","name","value","panic","getMissingNameErrorMessage","push","catch","findGraphQLTags","fs","require","crypto","stripIndent","cache","FileParser","parseFile","readFile","indexOf","hash","createHash","update","digest","astDefinitions","kind","parseFiles","files","documents","Map","all","map","doc","set"],"mappings":"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","file":"file-parser.js","sourcesContent":["// @flow\nconst fs = require(`fs-extra`)\nconst crypto = require(`crypto`)\n\n// Traverse is a es6 module...\nimport traverse from \"babel-traverse\"\nconst babylon = require(`babylon`)\n\nconst report = require(`gatsby-cli/lib/reporter`)\nconst { getGraphQLTag } = require(`../../utils/babel-plugin-extract-graphql`)\n\nimport type { DocumentNode, DefinitionNode } from \"graphql\"\n\nconst apiRunnerNode = require(`../../utils/api-runner-node`)\n\nconst getMissingNameErrorMessage = file => report.stripIndent`\n  GraphQL definitions must be \"named\".\n  The query with the missing name is in ${file}.\n  To fix the query, add \"query MyQueryName\" to the start of your query.\n  So instead of:\n    {\n      allMarkdownRemark {\n        totalCount\n      }\n    }\n\n  Do:\n    query MyQueryName {\n      allMarkdownRemark {\n        totalCount\n      }\n    }\n`\nasync function parseToAst(filePath, fileStr) {\n  let ast\n\n  // Preprocess and attempt to parse source; return an AST if we can, log an\n  // error if we can't.\n  const transpiled = await apiRunnerNode(`preprocessSource`, {\n    filename: filePath,\n    contents: fileStr,\n  })\n\n  if (transpiled && transpiled.length) {\n    for (const item of transpiled) {\n      try {\n        const tmp = babylon.parse(item, {\n          sourceType: `module`,\n          plugins: [`*`],\n        })\n        ast = tmp\n        break\n      } catch (error) {\n        report.error(error)\n        continue\n      }\n    }\n    if (ast === undefined) {\n      report.error(`Failed to parse preprocessed file ${filePath}`)\n    }\n  } else {\n    try {\n      ast = babylon.parse(fileStr, {\n        sourceType: `module`,\n        sourceFilename: true,\n        plugins: [`*`],\n      })\n    } catch (error) {\n      report.error(\n        `There was a problem parsing \"${filePath}\"; any GraphQL ` +\n          `fragments or queries in this file were not processed. \\n` +\n          `This may indicate a syntax error in the code, or it may be a file type ` +\n          `That Gatsby does not know how to parse.`\n      )\n    }\n  }\n\n  return ast\n}\n\nasync function findGraphQLTags(file, text): Promise<Array<DefinitionNode>> {\n  return new Promise((resolve, reject) => {\n    parseToAst(file, text)\n      .then(ast => {\n        let queries = []\n        if (!ast) {\n          resolve(queries)\n          return\n        }\n\n        traverse(ast, {\n          ExportNamedDeclaration(path, state) {\n            path.traverse({\n              TaggedTemplateExpression(innerPath) {\n                const gqlAst = getGraphQLTag(innerPath)\n                if (gqlAst) {\n                  gqlAst.definitions.forEach(def => {\n                    if (!def.name || !def.name.value) {\n                      report.panic(getMissingNameErrorMessage(file))\n                    }\n                  })\n\n                  queries.push(...gqlAst.definitions)\n                }\n              },\n            })\n          },\n        })\n        resolve(queries)\n      })\n      .catch(reject)\n  })\n}\n\nconst cache = {}\n\nexport default class FileParser {\n  async parseFile(file: string): Promise<?DocumentNode> {\n    let text\n    try {\n      text = await fs.readFile(file, `utf8`)\n    } catch (err) {\n      report.error(`There was a problem reading the file: ${file}`, err)\n      return null\n    }\n\n    if (text.indexOf(`graphql`) === -1) return null\n    const hash = crypto\n      .createHash(`md5`)\n      .update(file)\n      .update(text)\n      .digest(`hex`)\n\n    try {\n      let astDefinitions =\n        cache[hash] || (cache[hash] = await findGraphQLTags(file, text))\n\n      return astDefinitions.length\n        ? {\n            kind: `Document`,\n            definitions: astDefinitions,\n          }\n        : null\n    } catch (err) {\n      report.error(\n        `There was a problem parsing the GraphQL query in file: ${file}`,\n        err\n      )\n      return null\n    }\n  }\n\n  async parseFiles(files: Array<string>): Promise<Map<string, DocumentNode>> {\n    const documents = new Map()\n\n    return Promise.all(\n      files.map(file =>\n        this.parseFile(file).then(doc => {\n          if (!doc) return\n          documents.set(file, doc)\n        })\n      )\n    ).then(() => documents)\n  }\n}\n"]}